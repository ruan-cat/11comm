# 生成标准的列表页和表单弹框

在本次对话内，我们将完成各个列表页的生成。按照模板生成即可。本次对话的主要任务是套模板。

这里有很多注意事项，请严格遵照注意事项来完成代码生成。

请你阅读本文件，并给我一个**生成计划**和**生成规范**。告诉我套模板时，需要注意哪些内容。

这些注意事项会动态更新，我会要求你重新阅读，并修正你的计划、和生成规范。

## 参考页

### 命令式弹框

- 命令式弹框源码： `apps\admin\src\views\components\dialog\index.vue`
- 弹框案例： https://pure-admin.github.io/vue-pure-admin/#/components/dialog

## 分批次生成表格和弹框表单

在对话时，我会给你一张截图，请根据截图来生成列表页、和我需要的表单。

### 生成表格时

请你根据图片识别，读取出一个`表格`所需要的字段、和`搜索栏`所需要的字段。

### 生成表单时

请你根据图片识别，读取出一个`表单`所需要的字段，包括`必填项`和`非必填项`。

## 基于 addDialog 的命令式弹框

模仿 `apps\admin\src\pages\property-manage\expense-manage\expense-item-setting\index.vue` 文件。

模仿该文件，务必根据我提供的截图，来做手生成表单和弹框。

如果我没有提供实现表单的截图，或者是生成表单的要求时，请不要开始生成弹框和表单。

## 使用 useMode 组合式 api 实现模式控制

每一个弹框表单，都需要实现模式控制。根据模式来做出不同的行为。典型的是根据`新增`或`编辑`模式，动态更新弹框`标题`或`调用不同的接口`。

## 固定编写一段测试的异步函数

在生成命令式弹框的前面，你固定地使用以下代码段，实现一个模拟的异步操作。

```ts
const [isLoadingT, setIsLoadingT] = useToggle(false);
async function testAsync() {
	setIsLoadingT(true);
	consola.log("模拟异步操作, isLoadingT ", isLoadingT.value);
	await sleep(1300);
	setIsLoadingT(false);
	consola.log("模拟异步操作, isLoadingT ", isLoadingT.value);
}
```

## 主动为新增或编辑按钮增加打开弹框函数

在你生成命令式弹框的函数时，你也应该主动的将打开弹框的函数，应用到按钮上。比如新增按钮和编辑按钮。

## 弹框组件实例

比如以下例子：

```ts
import { type ExpenseItemSettingFormProps, defaultForm } from "./components/form";
import ExpenseItemSettingForm from "./components/form.vue";

const expenseItemSettingFormInstance = ref<InstanceType<typeof ExpenseItemSettingForm> | null>(null);
```

- 使用相对路径的方式，导入表单组件。该组件将作为弹框组件的实例。
- 在导入完表单后，随即新建弹框组件的实例。
- 实例必须预备好实例的类型，使用工具类型 `InstanceType` 来获得到实例类型。

## 严格的 addDialog 打开弹框函数传参

实现命令式弹框，最重要的就是二次封装 addDialog 函数。该函数有一系列严格的传参，请阅读以下内容。

## defaultAddDialogParams 默认弹框属性

每一个弹框都包含有这些默认属性，请直接使用以下的方式实现解构赋值。

```ts
addDialog({
	...defaultAddDialogParams,
});
```

1. 全局导入：该变量 defaultAddDialogParams 是全局导入的，你不需要考虑如何导入该对象。
2. 必须写在第一行：该变量包含了很多预设的变量，故需要以解构赋值的方式，写在第一行。便于其他可能的覆盖。
3. 不需要重复定义：该变量是全局导入的，请不要再重复定义一次。

## title 弹框标题

弹框标题往往是动态变化的，请你使用组合式 api useMode 函数来实现标题动态变化。其中，useMode 是全局自动导入的函数，不需要你手动导入。

如以下模板所示：

```ts
const { modeText } = useMode();

/** 打开弹框 */
function openDialog() {
	/** 弹框标题 */
	const title = `${modeText.value}费用项设置`;

	addDialog({
		title,
	});
}
```

如果标题不是动态变化的，是固定的，也请定义单独的 title 常量。

```ts
/** 打开弹框 */
function openDialog() {
	/** 弹框标题 */
	const title = `费用项设置`;

	addDialog({
		title,
	});
}
```

## props 弹框属性

即被渲染组件的 props。一般是表单组件的 props。

如以下模板所示：

- 以相对路径的方式，获取到表单组件的 props 属性类型。
- 获取弹框组件的默认表单对象 defaultForm。
- 组装 formProps 时，务必对传入的值做一次深克隆 cloneDeep。其中，cloneDeep 是全局自动导入的函数，不需要你手动导入。
- 在 addDialog 函数中传入 props 对象。

```ts
import { type ExpenseItemSettingFormProps, defaultForm } from "./components/form";

function openDialog() {
	/** 表单组件需要的props */
	const formProps: ExpenseItemSettingFormProps = {
		form: cloneDeep(defaultForm),
		defaultValues: cloneDeep(defaultForm),
	};

	/** 弹框组件所需的变量 */
	const props = formProps;

	addDialog({
		props,
	});
}
```

## contentRenderer 弹框渲染函数

命令式弹框渲染组件，使用的是，vue 的渲染函数语法。

具体写法如下例子所示：

- ExpenseItemSettingForm 是通过相对路径导入的被渲染组件。通常是表单组件。
- expenseItemSettingFormInstance 是被渲染组件的组件实例。
- formProps 是该组件全部的 props 对象。

```ts
addDialog({
	contentRenderer: () =>
		h(ExpenseItemSettingForm, {
			ref: expenseItemSettingFormInstance,
			...formProps,
		}),
});
```

## doBeforeClose 关闭回调函数

弹框关闭时，必须提供通用的关闭回调函数，写法几乎是固定的。

如下例子：

```ts
function openDialog() {
	/** 表单组件需要的props */
	const formProps: ExpenseItemSettingFormProps = {
		form: cloneDeep(defaultForm),
		defaultValues: cloneDeep(defaultForm),
	};

	/** 弹框组件所需的变量 */
	const props = formProps;

	/** 根据不同模式下 变化的表单默认重置对象 */
	const defaultValues = props.defaultValues;

	addDialog({
		async doBeforeClose({ options, index }) {
			const formComputed = expenseItemSettingFormInstance.value.formComputed;
			await useDoBeforeClose({ defaultValues, formComputed, index, options });
		},
	});
}
```

其中，expenseItemSettingFormInstance 是弹框组件的实例。要从弹框组件内获取固定对外导出的 formComputed 变量。

在你实际生成时，请你替换为实际的弹框组件实例。

useDoBeforeClose 函数是全局导入的函数，不需要你手动导入。

## footerButtons 弹框底部按钮栏

请严格按照我提供给你的模板。编排按钮的位置、样式、和其他固定的交互函数。

如下例子：

```js
const config = {
	footerButtons: [
		{
			label: transformI18n($t("common.buttons.cancel")),
			type: "info",
			btnClick: async ({ dialog: { options, index }, button }) => {
				// console.log(options, index, button);
				const formComputed = expenseItemSettingFormInstance.value.formComputed;
				await useDoBeforeClose({ defaultValues, formComputed, index, options });
			},
		},

		{
			label: transformI18n($t("common.buttons.reset")),
			type: "warning",
			btnClick: ({ dialog: { options, index }, button }) => {
				// 手动重置表单
				expenseItemSettingFormInstance.value.plusFormInstance.handleReset();
			},
		},

		{
			label: transformI18n($t("common.buttons.submit")),
			type: "success",
			btnClick: async ({ dialog: { options, index }, button }) => {
				// 提交表单时 校验
				const res = await expenseItemSettingFormInstance.value.plusFormInstance.handleSubmit();
				if (res) {
					button.btn.loading = true;
					await testAsync();
					button.btn.loading = false;
					closeDialog(options, index);
				}
			},
		},
	],
};
```

### 严格的按钮排布顺序

1. 取消按钮
2. 重置按钮
3. 提交按钮

该顺序不能错乱。

### 取消按钮

取消按钮的固定模板如下：

```js
const footerButtons = [
	{
		label: transformI18n($t("common.buttons.cancel")),
		type: "info",
		btnClick: async ({ dialog: { options, index }, button }) => {
			const formComputed = expenseItemSettingFormInstance.value.formComputed;
			await useDoBeforeClose({ defaultValues, formComputed, index, options });
		},
	},
];
```

请注意将 expenseItemSettingFormInstance 替换成实际的表单组件实例。

### 重置按钮

重置按钮的固定模板如下：

```js
const footerButtons = [
	{
		label: transformI18n($t("common.buttons.reset")),
		type: "warning",
		btnClick: ({ dialog: { options, index }, button }) => {
			expenseItemSettingFormInstance.value.plusFormInstance.handleReset();
		},
	},
];
```

请注意将 expenseItemSettingFormInstance 替换成实际的表单组件实例。

### 提交按钮

提交按钮的固定模板如下：

```js
const footerButtons = [
	{
		label: transformI18n($t("common.buttons.submit")),
		type: "success",
		btnClick: async ({ dialog: { options, index }, button }) => {
			const res = await expenseItemSettingFormInstance.value.plusFormInstance.handleSubmit();
			if (res) {
				button.btn.loading = true;
				await testAsync();
				button.btn.loading = false;
				closeDialog(options, index);
			}
		},
	},
];
```

1. 请注意将 expenseItemSettingFormInstance 替换成实际的表单组件实例。
2. 请注意，务必先生成好固定的，测试的异步函数。测试用的异步函数在此处使用。

## 基于 `<PlusForm>` 表单组件实现的 form.vue

在你生成表单的代码时，请你务必遵守以下规范和要求：

参考代码：`apps\admin\src\pages\property-manage\expense-manage\expense-item-setting\components\form.vue`

请你务必认真阅读代码实现。

### 获取表单组件实例

### 表单重设 usePlusFormReset

表单重设的默认逻辑，一定要用 usePlusFormReset 组合式 api 实现。必须在获取到表单实例后，就开始使用该函数实现表单重设。

usePlusFormReset 的源码实现如下： `apps\admin\src\composables\use-plus-form-reset\index.ts`

请你直接使用 usePlusFormReset 函数即可，就像这样：

```ts
/** 表单组件实例 要求对外直接导出本表单实例 */
const plusFormInstance = useTemplateRef("plusFormRef");
usePlusFormReset(plusFormInstance);
```

获取到表单实例后，就直接使用 usePlusFormReset 函数即可。不要试图从这个组合式 api 函数内结构出任何工具，请严格按照该要求实现表单组件的生成。

### 默认对外导出函数

表单组件必须默认导出：

- plusFormInstance 表单组件实例
- formComputed 动态计算的，只读的，当前表单对象

列表页的`命令式弹框`函数，需要使用表单组件对外导出的内容来实现业务。

### 根标签不允许包裹多余的 dom 元素

实现表单组件时，应该直接使用 PlusForm 组件。不要包裹多余的 dom 元素，不要多余的标签。

### 必须设置宽高的固定样式

必须为表单组件设置默认的宽高演示，仅使用以下的选择器写法：

```scss
.form-root {
	height: 100%;
	width: 100%;
}
```
